import { ValidationErrorInterface } from "./ValidationErrorInterface";
import { ValidationOptions, IsEmailOptions, IsFQDNOptions, IsFloatOptions, IsURLOptions, IsIntOptions, IsCurrencyOptions } from "./ValidationOptions";
/**
 * Validator performs validation of the given object based on its metadata.
 */
export declare class Validator {
    private _container;
    private metadataStorage;
    container: {
        get(type: Function): any;
    };
    /**
     * Performs validation of the given object based on annotations used in given object class.
     */
    validate(object: any, validationOptions?: ValidationOptions): ValidationErrorInterface[];
    /**
     * Performs validation of the given object based on annotations used in given object class.
     * Performs in async-style, useful to use it in chained promises.
     */
    validateAsync<T>(object: T, validationOptions?: ValidationOptions): Promise<T>;
    /**
     * Performs validation of the given object based on annotations used in given object class.
     * If validation is not passed then throws ValidationError.
     */
    validateOrThrow(object: any, validationOptions?: ValidationOptions): void;
    /**
     * Performs sanitization of the given object based on annotations used in given object class.
     */
    sanitize(object: any): void;
    /**
     * Performs sanitization of the given object based on annotations used in given object class.
     * Performs in async-style, useful to use it in chained promises.
     */
    sanitizeAsync<T>(object: T): Promise<T>;
    /**
     * Performs sanitization and validation of the given object based on annotations used in given object class.
     */
    sanitizeAndValidate(object: any, validationOptions?: ValidationOptions): ValidationErrorInterface[];
    /**
     * Performs sanitization and validation of the given object based on annotations used in given object class.
     * Performs in async-style, useful to use it in chained promises.
     */
    sanitizeAndValidateAsync<T>(object: T, validationOptions?: ValidationOptions): Promise<T>;
    /**
     * Checks if given object is valid (all annotations passes validation). Returns true if its valid, false otherwise.
     */
    isValid(object: any, validationOptions?: ValidationOptions): boolean;
    /**
     * Checks if the string contains the seed.
     */
    contains(str: string, seed: string): boolean;
    /**
     * Checks if the string matches the comparison.
     */
    equals(str: string, comparison: string): boolean;
    /**
     * Checks if the string is a date that's after the specified date.
     */
    isAfter(date: string, afterDate: Date): boolean;
    isAfter(date: Date, afterDate: string): boolean;
    isAfter(date: string, afterDate: string): boolean;
    isAfter(date: Date, afterDate: Date): boolean;
    /**
     * Checks if the string contains only letters (a-zA-Z).
     */
    isAlpha(str: string): boolean;
    /**
     * Checks if the string contains only letters and numbers.
     */
    isAlphanumeric(str: string): boolean;
    /**
     * Checks if the string contains ASCII chars only.
     */
    isAscii(str: string): boolean;
    /**
     * Checks if a string is base64 encoded.
     */
    isBase64(str: string): boolean;
    /**
     * Checks if the string is a date that's before the specified date.
     */
    isBefore(date: string, beforeDate: Date): boolean;
    isBefore(date: Date, beforeDate: string): boolean;
    isBefore(date: string, beforeDate: string): boolean;
    isBefore(date: Date, beforeDate: Date): boolean;
    /**
     * Checks if a string is a boolean.
     */
    isBooleanString(str: any): boolean;
    /**
     * Checks if a boolean is a real boolean;
     */
    isBoolean(value: any): boolean;
    /**
     * Checks if the string's length (in bytes) falls in a range.
     */
    isByteLength(str: string, min: number, max?: number): boolean;
    /**
     * Checks if the string is a credit card.
     */
    isCreditCard(str: string): boolean;
    /**
     * Checks if the string is a valid currency amount.
     */
    isCurrency(str: string, options?: IsCurrencyOptions): boolean;
    /**
     * Checks if the string is a date.
     */
    isDate(str: string): boolean;
    /**
     * Checks if the string represents a decimal number, such as 0.1, .3, 1.1, 1.00003, 4.0, etc.
     */
    isDecimal(str: string): boolean;
    /**
     * Checks if the string is a number that's divisible by another.
     */
    isDivisibleBy(str: string, num: number): boolean;
    /**
     * Checks if the string is an email.
     */
    isEmail(str: string, options: IsEmailOptions): boolean;
    /**
     * Checks if the string is a fully qualified domain name (e.g. domain.com).
     */
    isFQDN(str: string, options: IsFQDNOptions): boolean;
    /**
     * Checks if the string is a float.
     */
    isFloat(val: number, options: IsFloatOptions): boolean;
    isFloat(val: string, options: IsFloatOptions): boolean;
    /**
     * Checks if the string contains any full-width chars.
     */
    isFullWidth(str: string): boolean;
    /**
     * Checks if the string contains any half-width chars.
     */
    isHalfWidth(str: string): boolean;
    /**
     * Checks if the string contains variable-width chars.
     */
    isVariableWidth(str: string): boolean;
    /**
     * Checks if the string is a hexadecimal color.
     */
    isHexColor(str: string): boolean;
    /**
     * Checks if the string is a hexadecimal number.
     */
    isHexadecimal(str: string): boolean;
    /**
     * Checks if the string is an IP (version 4 or 6).
     */
    isIP(str: string, version?: number): boolean;
    /**
     * Checks if the string is an ISBN (version 10 or 13).
     */
    isISBN(str: string, version?: number): boolean;
    /**
     * Checks if the string is an ISIN (stock/security identifier).
     */
    isISIN(str: string): boolean;
    /**
     * Checks if the string is a valid ISO 8601 date.
     */
    isISO8601(str: string): boolean;
    /**
     * Checks if the string is in a array of allowed values.
     */
    isIn(str: string, values: any[]): boolean;
    /**
     * Checks if the string is an integer.
     */
    isInt(val: number, options: IsIntOptions): boolean;
    isInt(val: string, options: IsIntOptions): boolean;
    /**
     * Checks if the string is valid JSON (note: uses JSON.parse).
     */
    isJSON(str: string): boolean;
    /**
     * Checks if the string's length falls in a range. Note: this function takes into account surrogate pairs.
     */
    isLength(str: string, min: number, max?: number): boolean;
    /**
     * Checks if the string is lowercase.
     */
    isLowercase(str: string): boolean;
    /**
     * Checks if the string is a mobile phone number (locale is one of ['zh-CN', 'zh-TW', 'en-ZA', 'en-AU', 'en-HK',
     * 'pt-PT', 'fr-FR', 'el-GR', 'en-GB', 'en-US', 'en-ZM', 'ru-RU', 'nb-NO', 'nn-NO', 'vi-VN', 'en-NZ']).
     */
    isMobilePhone(str: string, locale: string): boolean;
    /**
     * Checks if the string is a valid hex-encoded representation of a MongoDB ObjectId.
     */
    isMongoId(str: string): boolean;
    /**
     * Checks if the string contains one or more multibyte chars.
     */
    isMultibyte(str: string): boolean;
    /**
     * Checks if value is null.
     * @deprecated
     */
    isNull(value: any): boolean;
    /**
     * Checks if the string is numeric.
     */
    isNumeric(str: string): boolean;
    /**
     * Checks if the string contains any surrogate pairs chars.
     */
    isSurrogatePair(str: string): boolean;
    /**
     * Checks if the string contains any surrogate pairs chars.
     */
    isURL(str: string, options: IsURLOptions): boolean;
    /**
     * Checks if the string is a UUID (version 3, 4 or 5).
     */
    isUUID(str: string, version?: number): boolean;
    /**
     * Checks if the string is uppercase.
     */
    isUppercase(str: string): boolean;
    /**
     * Checks if string matches the pattern. Either matches('foo', /foo/i) or matches('foo', 'foo', 'i').
     */
    matches(str: string, pattern: RegExp, modifiers?: string): boolean;
    /**
     * Remove characters that appear in the blacklist. The characters are used in a RegExp and so you will need to
     * escape some chars, e.g @Blacklist('\\[\\]')
     */
    blacklist(str: string, chars: string): string;
    blacklist(str: string, chars: RegExp): string;
    /**
     * Replace <, >, &, ', " and / with HTML entities.
     */
    escape(str: string): string;
    /**
     * Trim characters from the left-side of the input.
     */
    ltrim(str: string, chars?: string[]): string;
    /**
     * Canonicalize an email address.
     */
    normalizeEmail(str: string, lowercase?: boolean): string;
    /**
     * Trim characters from the right-side of the input.
     */
    rtrim(str: string, chars?: string[]): string;
    /**
     * Remove characters with a numerical value < 32 and 127, mostly control characters.
     * If keepNewLines is true, newline characters are preserved (\n and \r, hex 0xA and 0xD).
     * Unicode-safe in JavaScript.
     */
    stripLow(str: string, keepNewLines?: boolean): string;
    /**
     * Convert the input to a boolean.
     * Everything except for '0', 'false' and '' returns true. In strict mode only '1' and 'true' return true.
     */
    toBoolean(input: any, isStrict?: boolean): boolean;
    /**
     * Convert the input to a date, or null if the input is not a date.
     */
    toDate(input: any): Date;
    /**
     * Convert the input to a float.
     */
    toFloat(input: any): number;
    /**
     * Convert the input to an integer, or NaN if the input is not an integer.
     */
    toInt(input: any, radix?: number): number;
    /**
     * Convert the input to a string.
     */
    toString(input: any): string;
    /**
     * Trim characters (whitespace by default) from both sides of the input. You can specify chars that should be trimmed.
     */
    trim(str: string, chars?: string[]): string;
    /**
     * Remove characters that do not appear in the whitelist.
     * The characters are used in a RegExp and so you will need to escape some chars, e.g. whitelist(input, '\\[\\]').
     */
    whitelist(str: string, chars: string): string;
    whitelist(str: string, chars: RegExp): string;
    private performValidation(value, metadata);
    private sanitizeValue(value, metadata);
    private createInstance(object);
}
